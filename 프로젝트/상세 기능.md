# 뷰 서비스



## 테스트 구현

1. DI

   1. @ExtendWith(MockitoExtension.class)
   2. service 는 @InjectMocks
   3. 나머지는 @Mock

2. test 코드

   1. @test

   2. 함수 작성

      given_when_then(){} 

   3. 비교

      assertThat()

```java
@DisplayName("비즈니스 로직 - 게시글")
@ExtendWith(MockitoExtension.class) // spring boot slice test 안하고 해보기 - 가볍게 만들기
class ArticleServiceTest {

    @InjectMocks private ArticleService sut;

    @Mock
    private ArticleRepository articleRepository;

    @DisplayName("게시글을 검색하면, 게시글 리스트를 반환한다.")   // 게시글, 페이지네이션, 정렬
    @Test
    void givenSearchParameter_whenSearchArticles_thenReturnArticleList() {
        // Given

        // When
        Page<ArticleDto> articles = sut.searchArticles(); // 제목, 본문, ID, 닉네임, 해시태그

        // Then
        assertThat(articles).isNotNull();
    }
```

1. 게시판
   1. 정렬
   2. 검색
   3. 모든 게시글 보기
   4. 선택한 게시글만 보기
   5. 루트 페이지로 이동
2. 게시글
   1. 게시글 CRUD
   2. 댓글 CRUD

3. 로그인

   spring security



4. 한거

   도메인, dto, 서비스, 서비스테스트, 도메인과 dto 연동코드, response(필요정보만)



## 기타 설정

1. JPA buddy  ignore 설정 추가

   .jpb 폴더 생성되서

2. erd 속성 이름 주의점

   예약어랑 같으면 안됨

3. OSIV off 

   * application.yml에서 off

   ```yaml
   spring:
   	jpa:
   		open-in-view: false
   ```

   *  domain, dto 분리 -> 서비스가 나간뒤 트랜잭션 종료, 서비스에서 마무리가 된 데이터가 controller로 오게끔

     ![image-20230116210637823](md-images/image-20230116210637823.png)

   * 각 layer의 독립성 보장

     service - 도메인, dto 존재 앎

     controller는 request나 respone 존재만 앎





---

#19

feature 길어지면 branch만들어서 main 말고 만든 branch에 merge



getReferenceBy 와 findBy 차이



## 서비스 구현

1. 게시판 비스니스 로직 구현
    	1. 검색, CRUD
            	1. respsitory 함수 추가
                	2. service에서 
                  	1. repository 함수 사용
                     	2.  dto->entity 변환  





2. 게시판 controller 구현

   1. request 변수 받기

   1. response 
      1. service함수 사용 + response 도메인으로 받기
      2. map에 담기

   3. 테스트

      @MockBean service

      service는 생성자 주입으로 안됨 -> filed injection @MockBean 사용



3. 게시판 view 구현

   1. 정보가 들어갈 곳에 class 이름 설정 

   2. th.xml에 이름설정한 class에 들어갈 내용 적기



4. 도메인과 dto 분리하는 이유	

​	하나의 거대한 범용 class를 여러 layer가 공통적으로 사용하면 문제 발생

1. 특정상황에서만 값이 존재하는 필드

2. 초기화되는 시점과 사용되는 시점이 필드군마다 제각각이라 유지보수 어려움

3. 여러 layer의 Annotation이 한데 섞여 한눈에 이해하기 어려움



5. pageable 

   자동으로 크기가 10인 페이지 객체 만들어줌

---

#24 pagination

1. prev, next
2. 현재페이지 가운데 배치



# Pagination

게시판, 게시글

1. pagination service test
   1. 현재페이지, 전체페이지 / 예상페이지 비교
   2. 페이지 바 길이 5인지 확인
2. pagianation service
   1. 현재페이지, 전체페이지 -> 현제페이지 가운데인 길이 5인 페이지바
   2. 페이지 바 길이 출력

3. controller test

   1. 현재페이지, 전체페이지 주어지면

      요청이 주어질 때

      페이지바 속성이 있는지 확인

4. controller

   map의 페이지바 속성에 service값 넣기

5. html

   값넣을 곳에 class 이름 넣기

6. th.xml

   값 넣을 곳에 넣을 값 설정



# 정렬

도메인 코드에 의해 정렬됨

th.xml로 정렬



# 검색

html 로 검색타입, 검색어 받아오기 설정

1. controller로
   1. @RequestParam으로 검색기준, 검색어 가져오기
   2. service 결과를 map에 담기

2. searchtype.description을 위해 도메인에 있는 searchType 수정

3. repository

   1. querydsl 사용

4. 검색 service 구현

5. html

   1. form태그, 
      1. 클래스 - 값 넣기를 위해
      2. 변수이름 - @RequestParam을 위해

6. th.xml

   값 넣기

   

# MethodSource

한번에 여러개 넣고 테스트하기



https://ebabby.tistory.com/28





# 해시태그 검색 구현 #32



# 댓글 구현

읽기는 게시글 구현 때 구현했었음

update, delete 구현

1. domain, dto
   1. articltCommentRequest 도메인
   2. articlCommentDto
2. controller test -> controller 
   1. 저장
      1. mapping - post -> html에서 form을 사용하므로 post씀
      2. service 사용
      3. redirect 할 뷰
   2. 삭제
      1. mapping - post -> html에서 form을 사용하므로 post씀
      2. service 사용
      3. redirect 할 뷰
3. service test -> serivce
   1. 저장
      1. 저장할 값 만들기
      2. respository 함수로 저장
   2. 삭제
      1. respository 함수로 삭제
4. 뷰구현
   1. 쓰기
   2. 삭제

유저 인증 필요



csrf - 웹보안 -> CUD 할때는 해줘야 됨



spring 2.7 releases -> Auto - configure 바뀜 : 저장 위치가 spring.factories로 바뀜 -> IntelliJ 1.3이상 권장



테스트 - 필드주입, 생성자 주입?????



record : 간결한 data class

*  final 클래스이라 상속할 수 없다.

- 각 필드는 private final 필드로 정의된다.
- RequiredAllArgument 생성자가 자동 생성
- getName() -> name()

https://coding-start.tistory.com/355



getReference() vs find

getReference() : 영속성 컨텍스트에서 가짜 Entity 가져오기

find() : DB에서 실제Entity 가져오기

* https://lifedeveloper.tistory.com/entry/JPA%ED%94%84%EB%A1%9D%EC%8B%9C-getReference



# 인증 기능 구현

1. 설정

   1. securityConfig

      1. 인증 설정

         1. 인증요구 안하는 곳 설정
         2. 로그인
         3. 로그아웃 
         4. redirection

      2. 정적페이지 제외 시키기(바뀜)

         * 기존은 WebSecurityCustomizer Bean을 따로 생성해서 설정해줬으나 warining 뜸

         * 이제는 인증설정하는 곳에 같이 설정해줌

      3. DB 정보로 인증정보 가져오기

         1. 유저계정 findyById
         2. 유저계정 UserAccountDto로 변환
         3. 유저계정 BoardPrincipal로 변환
         4. 예외처리

      4. pwd encoder : 암호화

   2. JpaConfig 수정

      1. SecurityConfigure 가져오기
      2. 인증했는지 가져오기
      3. 안했으면 principal 가져오기
      4. principal 구현한 class 가져오기
      5. 인증정보 가져오기

      

      

2. 인증정보(Boardprincipal)구현

   1. 구현방법(선택)
      1. User(이미구현된거) 상속받기
      2. 직접 구현하기
   2. 권한은 USER만
   3. from : pricipal에 회원정보 저장 용도
   4. to : principal -> dto



3. controller

   인증 추가

4. service

   인증 추가

5. repository

   1. 쿼리 메소드

      인증정보와 userId 비교하기 위해 매개변수에 userId추가

      1. 삭제
      2. 수정





6. controller test

   1. userAccountrepository @MockBean 생성

      securityConfig에서 userAccountrepository 를 사용하므로  

   2. 인증 필요한 부분 통과시키기
      1. @WithUserDetails(사용자Id)
      2. @WithMockUser

   3. import TestSecurityConfig

      TestSecurityConfig = SecurityConfig에서 UserAccountDto를 사용하므로 @MockBean 해줘야 됨

   

7. JpaRepositoryTest

   1. import TestSecurityConfig

   1. 인증때문에 test전용 config 사용







8. data.sql

​	암호화 정보를 넣어줘야 패스워드 인코더가 읽을 수 없어서 

​	패스워드에 `{noop}`추가



9. 인증 기능 뷰 연결

   자기가 쓴 글만 수정, 삭제 가능 및 표시



10. response dto에 userId가 필요하므로 update



12. Namespace `sec` is not bound 발생

    Thymeleaf에서 sec를 인식 못함 

    1. xmlns:sec = "주소" 추가
    2. build.gradle dependency에서 spring-security6에서 spring-security5로 변경

