# 비동기 프로그래밍

* 사용처	

  * 실시간성 응답을 필요로 하지 않는 상황

    ex) 알림, email 전송

* 개념

  Sub Thread에게 Task를 위임하는 행위

  

## ThreadPool

* 개념

  비동기 프로그래밍을 위해서 

  Sub Thread 생성, 관리 방법 알아야 됨 = ThreadPool 정의 해야됨

* 옵션
  1. CorePoolSize : Pool당 최소 Thread 갯수
  2. MaxPoolSize : Pool당 최대 Thread 갯수
  3. WorkQueue : Queue가 담을 수 있는 Task 갯수
  4. KeepAliveTime : 지정한 시간만큼 일을 안하면 Thread 반납(Threade 갯수가 CorePoolSize 초과일 때)

* 과정
  1. CorePoolSize만큼 Thread 생성
  2. Thread 수 > CorePoolSize -> Queue에 Task 담기
  3. Queue Full && Thread 수 < MaxPoolSize -> Thread 생성
  4. Queue Full && Thread 수 > MaxPoolSize -> Task 거절

* 사용방법

  * ThreadPoolExecutor 생성자

    ```java
    public ThreadPoolExecutor(int corePoolSize,
                             int maximumPoolSize,
                             long keepAliveTime,
                             TimeUnit unit,
                             BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
            Executors.defualtTrheadVactory(), defaultHandler)
    }
    ```

  * 사용 예제

    ````java
    // corePoolSize=5, maximumPoolSize=10,keepAliveTime=3, 시간단위=초, 큐크기=50
    ThreadPoolExecutor executoryPool = new ThreadPoolExecutor(5,10,3,TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(50));
    ````

* 주의점
  1. CorePoolSize 너무 크면 안됨
  2. IllegalArgumentException
     * CorePoolSize < 0
     * maximumPoolSize <= CorePoolSize 
     * keepAliveTime < 0
  3. NullPointerException 
     * workQueue is null



## Spring Async

* 비동기 처리를 위해서는 Spring의 도움이 필요함

  * 외부 메소드에 @Async를 하게 되면 wrappingg된 Proxy Object가 Container에 들어감
  *  Proxy Object를 DI 해야 Async가 됨

* 주의점

  DI + 외부 메소드(@Async("{ThreadPoolExecutor 이름}") + public)



## 실습

1. dependency 추가

   * lombok
   * Spring Web

2. 설정

   1. ThreadPool Bean으로 생성

      ```java
      @Configuration
      public class AppConfig {
      
          @Bean(name = "defaultTaskExecutor", destroyMethod = "shutdown")	// 이름, 생성안되는 경우 대비
          public ThreadPoolTaskExecutor defaultTaskExecutor() {
              ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
              executor.setCorePoolSize(200);
              executor.setMaxPoolSize(200);
              return executor;
          }
      
          @Bean(name = "messagingTaskExecutor", destroyMethod = "shutdown")
          public ThreadPoolTaskExecutor messagingTaskExecutor() {
              ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
              executor.setCorePoolSize(200);
              executor.setMaxPoolSize(200);
              return executor;
          }
      }
      ```

   2. Async Annotation 가능하게 설정

      ```java
      @Configuration
      @EnableAsync
      public class AsyncConfig {
      }
      ```

3. Contoroller : mapping + service DI + service 사용

4. service : Thread 이름 출력

   1. service를 DI가 아닌 생성자로 생성 -> 실패

   2. 내부 메소드에 @Async한 것을 사용 -> 실패

   3. 외부 메소드에 @Async한 것을 사용 -> 성공

      

# Feign Client

* 사용처

  외부 요청

  rest template이랑 비슷

* 개념

  선언적으로 사용할 수 있는 Client



## Connections/Read Timeout

* 외부 서버와 통신 시 client 별로 Timeout 설정이 가능



## Feign Interceptor

* 외부로 요청이 나가기 전에 만약 공통적으로 처리해야하는 부분이 있다면 

  Interceptor를 재정의하여 처리 가능



## Feing CustomLogger

* 운영(Reqeust/Response)을 하기 위한 적절한 Log를 남길수 있음



## Feign ErrorDecoder

* 요청에 대해 정상 응답이 아닌 경우 핸들링 가능



## 실습

1. build.gradle

   1. dependency 추가

      1. lombok

      2. Spring Web

      3. feign

         ```java
         // Feign
         implementation 'org.springframework.cloud:spring-cloud-starter-openfeign'
         ```

   2. dependencyManagement로 spring cloud 버전관리 설정

      ```java
      imports {
          mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
      }
      ```

   3. ext로 springCloudVersion 등록

      ```java
      ext {
          /**
      	 * Spring Boot and springCloudVersion must be compatible.
      	 * 2.6.x, 2.7.x (Starting with 2021.0.3) = 2021.0.x
      	 * ref : https://spring.io/projects/spring-cloud
      	 */
      	set('springCloudVersion', '2021.0.3')	// 위 ref에서 springboot에 맞는 release 찾기
      }
      ```

2. common : dto

   1. reqeust
   2. response

3. controller

   1. client Controller
   2. server Controller

4. serivice  : 요청값 넣기

   1. feign-client DI
   2. response = feign-client.함수(값)

5. config : global한 설정

   logger bean 등록

6. feign

   1. cllient

      1. interface
      2. @FeignClient로 name, url, configuration 설정
      3. mapping

   2. interceptor

      RequestInterceptor implements해서 구현하기

      1. GET request
      2. POST request

   3. config : local적인 설정

      1. interceptor bean 등록
      2. decoder bean 등록

   4. logger

      1. extends Logger(feign Logger 임)

      2. log : logformat

      3. logRequest : request 출력

      4. logAndRebufferResponse : response 출력

         1. 여기에서도 logRequest  설정 가능

         2. feign logger 복붙하고 수정하기

            1. 예상 요청 처리 시간보다 오래 걸렸다면 "Slow API"라는 log를 출력해보기 -> 네트워크 문제 확인 가능

               ```java
               private static final int DEFAULT_SLOW_API_TIME = 3_000;	// 예상 요청 시간
               private static final String SLOW_API_NOTICE = "Slow API";	// 원하는 로그
               ```

   5. decoder

      1. implements ErrorDecoder
      2. 특정 error 발생시 로그 설정
      3. 그외는 기존거 사용



# Logback 설정

* Log 관리