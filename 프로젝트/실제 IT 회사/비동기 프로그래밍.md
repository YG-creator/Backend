# 비동기 프로그래밍

* 사용처	

  * 실시간성 응답을 필요로 하지 않는 상황

    ex) 알림, email 전송

* 개념

  Sub Thread에게 Task를 위임하는 행위

  

## ThreadPool

* 개념

  비동기 프로그래밍을 위해서 

  Sub Thread 생성, 관리 방법 알아야 됨 = ThreadPool 정의 해야됨

* 옵션
  1. CorePoolSize : Pool당 최소 Thread 갯수
  2. MaxPoolSize : Pool당 최대 Thread 갯수
  3. WorkQueue : Queue가 담을 수 있는 Task 갯수
  4. KeepAliveTime : 지정한 시간만큼 일을 안하면 Thread 반납(Threade 갯수가 CorePoolSize 초과일 때)

* 과정
  1. CorePoolSize만큼 Thread 생성
  2. Thread 수 > CorePoolSize -> Queue에 Task 담기
  3. Queue Full && Thread 수 < MaxPoolSize -> Thread 생성
  4. Queue Full && Thread 수 > MaxPoolSize -> Task 거절

* 사용방법

  * ThreadPoolExecutor 생성자

    ```java
    public ThreadPoolExecutor(int corePoolSize,
                             int maximumPoolSize,
                             long keepAliveTime,
                             TimeUnit unit,
                             BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
            Executors.defualtTrheadVactory(), defaultHandler)
    }
    ```

  * 사용 예제

    ````java
    // corePoolSize=5, maximumPoolSize=10,keepAliveTime=3, 시간단위=초, 큐크기=50
    ThreadPoolExecutor executoryPool = new ThreadPoolExecutor(5,10,3,TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(50));
    ````

* 주의점
  1. CorePoolSize 너무 크면 안됨
  2. IllegalArgumentException
     * CorePoolSize < 0
     * maximumPoolSize <= CorePoolSize 
     * keepAliveTime < 0
  3. NullPointerException 
     * workQueue is null



## Spring Async

* 비동기 처리를 위해서는 Spring의 도움이 필요함

  * 외부 메소드에 @Async를 하게 되면 wrappingg된 Proxy Object가 Container에 들어감
  *  Proxy Object를 DI 해야 Async가 됨

* 주의점

  DI + 외부 메소드(@Async("{ThreadPoolExecutor 이름}") + public)



# 실습

## Dependency 추가

* lombok
* Spring Web



## ThreadPool Bean 생성

* 옵션
  * CorePoolSize : Pool당 최소 Thread 갯수
  * MaxPoolSize : Pool당 최대 Thread 갯수
  * WorkQueue : Queue가 담을 수 있는 Task 갯수
  * KeepAliveTime : 지정한 시간만큼 일을 안하면 Thread 반납(Threade 갯수가 CorePoolSize 초과일 때)
* destroyMethod : ThreadPool이  정의가 안되는 경우 대비

```java
@Configuration
public class AppConfig {

    @Bean(name = "defaultTaskExecutor", destroyMethod = "shutdown")	// ThreadPool이  정의가 안되는 경우 대비
    public ThreadPoolTaskExecutor defaultTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(200);
        executor.setMaxPoolSize(200);
        return executor;
    }

    @Bean(name = "messagingTaskExecutor", destroyMethod = "shutdown") // ThreadPool이  정의가 안되는 경우 대비
    public ThreadPoolTaskExecutor messagingTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(200);
        executor.setMaxPoolSize(200);
        return executor;
    }
}
```



## Async Annotation 설정

```java
@Configuration
@EnableAsync
public class AsyncConfig {
}
```



## Controller 구현

1. AsyncService DI
2. mapping 
3. AsyncService 사용



## Service 구현

1. EmailService 
   1. @Async로 ThreadPool 설정
   2. 현재 사용하는 Thread 이름 출력

2. AsyncService : 비동기 테스트
   1. 외부 메소드에 @Async한 것을 사용 -> 성공
   2. service를 DI가 아닌 생성자로 생성 -> 실패
   3. 내부 메소드에 @Async한 것을 사용 -> 실패
