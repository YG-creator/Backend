# 비동기 프로그래밍

* 사용처	

  * 실시간성 응답을 필요로 하지 않는 상황

    ex) 알림, email 전송

* 개념

  Sub Thread에게 Task를 위임하는 행위

  

## ThreadPool

* 개념

  비동기 프로그래밍을 위해서 

  Sub Thread 생성, 관리 방법 알아야 됨 = ThreadPool 정의 해야됨

* 옵션
  1. CorePoolSize : Pool당 최소 Thread 갯수
  2. MaxPoolSize : Pool당 최대 Thread 갯수
  3. WorkQueue : Queue가 담을 수 있는 Task 갯수
  4. KeepAliveTime : 지정한 시간만큼 일을 안하면 Thread 반납(Threade 갯수가 CorePoolSize 초과일 때)

* 과정
  1. CorePoolSize만큼 Thread 생성
  2. Thread 수 > CorePoolSize -> Queue에 Task 담기
  3. Queue Full && Thread 수 < MaxPoolSize -> Thread 생성
  4. Queue Full && Thread 수 > MaxPoolSize -> Task 거절

* 사용방법

  * ThreadPoolExecutor 생성자

    ```java
    public ThreadPoolExecutor(int corePoolSize,
                             int maximumPoolSize,
                             long keepAliveTime,
                             TimeUnit unit,
                             BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
            Executors.defualtTrheadVactory(), defaultHandler)
    }
    ```

  * 사용 예제

    ````java
    // corePoolSize=5, maximumPoolSize=10,keepAliveTime=3, 시간단위=초, 큐크기=50
    ThreadPoolExecutor executoryPool = new ThreadPoolExecutor(5,10,3,TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(50));
    ````

* 주의점
  1. CorePoolSize 너무 크면 안됨
  2. IllegalArgumentException
     * CorePoolSize < 0
     * maximumPoolSize <= CorePoolSize 
     * keepAliveTime < 0
  3. NullPointerException 
     * workQueue is null



## Spring Async

* 비동기 처리를 위해서는 Spring의 도움이 필요함

  * 외부 메소드에 @Async를 하게 되면 wrappingg된 Proxy Object가 Container에 들어감
  *  Proxy Object를 DI 해야 Async가 됨

* 주의점

  DI + 외부 메소드(@Async("{ThreadPoolExecutor 이름}") + public)



## 실습

1. dependency 추가

   * lombok
   * Spring Web

2. 설정

   1. ThreadPool Bean으로 생성

      ```java
      @Configuration
      public class AppConfig {
      
          @Bean(name = "defaultTaskExecutor", destroyMethod = "shutdown")	// 이름, 생성안되는 경우 대비
          public ThreadPoolTaskExecutor defaultTaskExecutor() {
              ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
              executor.setCorePoolSize(200);
              executor.setMaxPoolSize(200);
              return executor;
          }
      
          @Bean(name = "messagingTaskExecutor", destroyMethod = "shutdown")
          public ThreadPoolTaskExecutor messagingTaskExecutor() {
              ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
              executor.setCorePoolSize(200);
              executor.setMaxPoolSize(200);
              return executor;
          }
      }
      ```

   2. Async Annotation 가능하게 설정

      ```java
      @Configuration
      @EnableAsync
      public class AsyncConfig {
      }
      ```

3. Contoroller : mapping + service DI + service 사용

4. service : Thread 이름 출력

   1. service를 DI가 아닌 생성자로 생성 -> 실패

   2. 내부 메소드에 @Async한 것을 사용 -> 실패

   3. 외부 메소드에 @Async한 것을 사용 -> 성공

      

# Feign Client

* 사용처

  외부 요청

  rest template이랑 비슷

* 개념

  선언적으로 사용할 수 있는 Client



## Connections/Read Timeout

* 외부 서버와 통신 시 client 별로 Timeout 설정이 가능



## Feign Interceptor

* 외부로 요청이 나가기 전에 만약 공통적으로 처리해야하는 부분이 있다면 

  Interceptor를 재정의하여 처리 가능



## Feign CustomLogger

* 운영(Reqeust/Response)을 하기 위한 적절한 Log를 남길수 있음



## Feign ErrorDecoder

* 요청에 대해 정상 응답이 아닌 경우 핸들링 가능



## 실습

1. build.gradle

   1. dependency 추가

      1. lombok

      2. Spring Web

      3. feign

         ```java
         // Feign
         implementation 'org.springframework.cloud:spring-cloud-starter-openfeign'
         ```

   2. dependencyManagement로 spring cloud 버전관리 설정

      ```java
      imports {
          mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
      }
      ```

   3. ext로 springCloudVersion 등록

      ```java
      ext {
          /**
      	 * Spring Boot and springCloudVersion must be compatible.
      	 * 2.6.x, 2.7.x (Starting with 2021.0.3) = 2021.0.x
      	 * ref : https://spring.io/projects/spring-cloud
      	 */
      	set('springCloudVersion', '2021.0.3')	// 위 ref에서 springboot에 맞는 release 찾기
      }
      ```

2. common : dto

   1. reqeust
   2. response

3. controller

   1. client Controller
   2. server Controller

4. serivice  : 요청값 넣기

   1. feign-client DI
   2. response = feign-client.함수(값)

5. config : global한 설정

   logger bean 등록

6. feign

   1. cllient

      1. interface
      2. @FeignClient로 name, url, configuration 설정
      3. mapping

   2. interceptor

      RequestInterceptor implements해서 구현하기

      1. GET request
      2. POST request

   3. config : local적인 설정

      1. interceptor bean 등록
      2. decoder bean 등록

   4. logger

      1. extends Logger(feign Logger 임)

      2. log : logformat

      3. logRequest : request 출력

      4. logAndRebufferResponse : response 출력

         1. 여기에서도 logRequest  설정 가능

         2. feign logger 복붙하고 수정하기

            1. 예상 요청 처리 시간보다 오래 걸렸다면 "Slow API"라는 log를 출력해보기 -> 네트워크 문제 확인 가능

               ```java
               private static final int DEFAULT_SLOW_API_TIME = 3_000;	// 예상 요청 시간
               private static final String SLOW_API_NOTICE = "Slow API";	// 원하는 로그
               ```

   5. decoder

      1. implements ErrorDecoder
      2. 특정 error 발생시 로그 설정
      3. 그외는 기존거 사용



# Logback 설정

* 개념
  * SLF4J 인터페이스 구현하는 구현체
  * Logging Framework

* 사용하는 이유
  * Log 관리



## Appender

* ConsoleAppender : 콘솔에 log를 출력(개발 환경)
* FileAppender : 파일 단위로 log 를 저장(운영서버 환경) 
* RollingFileAppender : (설정 옵션에 따라) log 를 여러 파일로 나누어 저장 
* SMTPAppender : log 를 메일로 전송 하여 기록 
* DBAppender: log 를 DB에 저장





## Mdc

* 개념

  멀티쓰레드 환경에서 로그를 남길 때 사용하는 개념

* 사용하는 이유

  로그에서 저장되어있는 값을 동적으로 출력하기 위해서



## 사용법

### 처음 logback 설정

1. logback-spring.xml 생성

   * resource에 생성

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <configuration>
       <!-- 기본 logback property 가져오기 -->
       <include resource="org/springframework/boot/logging/logback/defaults.xml" />
       <!-- Profile한 설정 가져오기 -->
       <include resource="logback-spring-${spring.profiles.active}.xml"/>
   </configuration>
   ```

2. logback-spring-{profile이름}.xml 생성

   * resource에 생성

   * 여기에 appender 설정 추가하면 됨

### ConsoleAppender 설정

1. logback-spring-{profile이름}.xml에서 설정

   1. console-appender properties 가져오기
   2. appender 설정
      1. 이름
      2. class
   3. log level 설정(Debug < Info < Warn < Error)
   4. log 출력 형식

   ```xml
   <included>
       <!-- 1. appender properties 가져오기 -->
       <include resource="org/springframework/boot/logging/logback/console-appender.xml" />
       
       <!-- appender 설정 -->
     	<appender name="CONSOLE2" class="ch.qos.logback.core.ConsoleAppender">	<!-- 2. appender 설정 -->
       	<filter class="ch.qos.logback.classic.filter.ThresholdFilter">
               <!-- 3. log level 설정(Debug < Info < Warn < Error)-->
               <level>INFO</level> 
       	</filter>
       	<layout>
         		<pattern> <!-- 4. log 출력 형식 -->
           		[CONSOLE2] [%-5level] %d{yyyy-MM-dd HH:mm:ss} [%thread] [%logger{0}:%line] - %msg%n
         		</pattern>
       	</layout>
     	</appender>
   </included>
   ```



### RollingFileAppender 설정

1. logback-spring-{profile이름}.xml에서 설정

   1. appender 설정
      1. 이름
      2. class
   2. 파일 위치 및 이름 설정
   3. rollingPolicy 설정
      1. 로그파일 위치 및 이름 패턴
      2. 로그파일의 최대 크기
      3. 로그파일 최대 보관 주기(단위 : 일)
   4. encoder 설정
      1. 로그 출력 형식
      2. header에 로그 출력 형식 노출

   ```xml
   <included>
       <!-- appender 설정 -->
       <appender name="REQUEST1" class="ch.qos.logback.core.rolling.RollingFileAppender">
       <file>log/request1.log</file>
       <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
         <fileNamePattern>log/archive/request1.%d{yyyy-MM-dd}_%i.log</fileNamePattern>
   <!--      <maxFileSize>10MB</maxFileSize>-->
         <maxFileSize>1KB</maxFileSize> <!-- 로그파일의 최대 크기 -->
         <maxHistory>30</maxHistory> <!-- 로그파일 최대 보관주기(단위 : 일) / 보관주기가 넘어가면 파일은 자동으로 삭제 -->
       </rollingPolicy>
       <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
         <pattern>[REQUEST1] [%-5level] %d{yyyy-MM-dd HH:mm:ss} [%thread] [%logger{0}:%line] - %msg%n</pattern>
         <outputPatternAsHeader>true</outputPatternAsHeader>
       </encoder>
     </appender>
   </included>
   ```

   

### 변수 설정해보기

1. logback-variables.properties 생성

   1. key와 value 입력

2. logback-spring-{profile이름}.xml에서 사용해보기

   1. 변수 설정 불러오기

      ```xml
      <property resource="logback-variables.properties" />
      ```

   2. `${key이름}` 을 변수처럼 사용 가능





### RollingFileAppender filtering by level

1. appender 설정에 filter 추가

   1. 레벨 설정
   2. 레벨 일치한 것만 filtering

   ```xml
   <filter class="ch.qos.logback.classic.filter.LevelFilter">
       <level>error</level>	<!-- 레벨 설정 -->
       <onMatch>ACCEPT</onMatch>	<!-- 레벨 일치하는 것만 -->
       <onMismatch>DENY</onMismatch>
   </filter>
   ```



### Mdc 설정

1. controller

   1. lombok
   2. mdc.put(key, value)
   3. log 출력
   4. mdc.clear

   ```java
   @Slf4j
   @RestController
   public class MdcController {
       @GetMapping("/mdc")
       public String mdc() {
           // key, value 등록
           MDC.put("job", "dev");
   		
           // log 출력
           log.trace("log --> TRACE");
           log.debug("log --> DEBUG");
           log.info("log --> INFO");
           log.warn("log --> WARN");
           log.error("log --> ERROR");
   		
           // mdc 삭제
           MDC.clear();
   
           return "mdc";
       }
   }
   ```

2. appender 설정에서 사용해보기

   `%X{key이름}`





### custom한 appender를 사용하기 

1. Profile 설정

   우측상단에서 설정

2. 사용할 appender 설정

   appender 설정한 곳에서 진행

   1. 모든 controller에 사용

      1. level 설정
      2. 사용할 appender 설정

      ```xml
      <root level="INFO">
          <appender-ref ref="{appender이름}" />
      </root>
      ```

   2. 특정 controller에만 사용

      1. logger 이름 설정
      2. level 설정
      3. 사용할 appender 설정

      ```xml
      <logger name="SQL_LOG2" level="INFO" additivity="false">
          <appender-ref ref="{appender이름}"/>
      </logger>
      ```

3. controller에 사용하기(선택)

   * @Slf4j 사용하기

     ```java
     @Slf4j(topic = "SQL_LOG1")	// 사용
     @RestController
     public class QueryController1 {
     
         @GetMapping("/query1")
         public String query() {
     
             log.trace("log --> TRACE");
             log.debug("log --> DEBUG");
             log.info("log --> INFO");
             log.warn("log --> WARN");
             log.error("log --> ERROR");
     
             if (true) {
                 throw new RuntimeException();
             }
     
             return "Query";
         }
     }
     ```

   * LoggerFactory DI

     ```java
     @RestController
     public class QueryController2 {
     
         public static final Logger log = LoggerFactory.getLogger("SQL_LOG2");	// 사용
     
         @GetMapping("/query2")
         public String query() {
     
             log.trace("log --> TRACE");
             log.debug("log --> DEBUG");
             log.info("log --> INFO");
             log.warn("log --> WARN");
             log.error("log --> ERROR");
     
             if (true) {
                 throw new RuntimeException();
             }
     
             return "Query";
         }
     }
     ```

     