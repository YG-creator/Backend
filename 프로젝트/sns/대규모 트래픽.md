# 문제점

## 코드의 비 최적화

* user 조회 중복

  * JwtTokenFilter + service에서 로그인 여부 확인

  * API 요청마다 로그인 여부확인함





## 기능간의 강한 결합성

* Alarm까지 생성해야 응답하는 API
  * 댓글 작성 API
  * 좋아요 API





## 수많은 DB IO

* JPA 써서 Query 최적화가 안됨

  * 체크 필요사항

    * idx 

    * join 체크





# 해결

![image-20230216200650256](md-images/image-20230216200650256.png)

![image-20230216201229620](md-images/image-20230216201229620.png)

![image-20230216201247183](md-images/image-20230216201247183.png)



## 코드 최적화

* 코드의 비 최적화 해결




## Redis

cache 기능 사용해서 해결

* 수많은 DB IO



## Kafka

비동기처리로 해결

* 기능간의 강한 결합성
  * 댓글작성 API 응답 받으면 Alarm event 발생
  * 좋아요 API 응답 받으면 Alarm event 발생



# 코드 최적화

## User 조회 중복

1. JwtFilter -> User 확인 결과 -> authentication에 담음 : 중복제거
2. respository 함수 변경 : join query 제거
   1. findAllByUser(userEntity) -> findAllByUserId(userId)
3. Controller
   1. authentication사용
      1. authentication에 userEntity가 있으면 userEntity 가져오기
      2. 없으면 INTERNAL_SERVER_ERROR 에러처리
         1. getsafeCastInstance(Object, class) 추가 구현 후 사용
            1. Object가 null이 아니고 class가 맞으면 object 반환
            2. 그 외는 empty 반환 
   2. Service에 user.getId()만 전달
   3. Service 결과 반환
4. Service
   1. findAllByUserId(userId) 결과를 반환



## selct count(*)

@Query(select count(*) ~) -> countByEntity(entity)로 쿼리 간단하게 하기



## JPA n+1 문제

* 문제

  * A join B 해서 한번에 가져오는게 원하는 것이지만
  * 실제로는 (A 전체 검색 -> A에 있는 foreing key로 검색) 반복

* 해결

  * @ManyToOne(fetch = FetchType.LAZY)

    사용하든 안하든 A전체 가져오기

    사용할때만 A에 있는 foreing key로 검색

* 실제해결법 : @Query로 작성



## Post Delete

포스트 삭제 시 -> 댓글이랑 좋아요도 같이 삭제

* 문제

  * 변경사항을 모두 반영한 후 삭제함

* 해결

  * 그냥 바로 삭제함

    삭제할 entity의 respository에 추가

    ```java
    @Transactionoal
    @Modifying
    @Query("UPDATE entity이름 entity SET deleted_at = NOW() where entity.pop = :post")
    void deletedAllByPost("post") PostEntity postEntity
    ```

    



# Redis caching

## User 조회 

1. Heroku adds-one에 Redis 추가

2. dependency 추가

   Spring Boot starter data redis maven 구글링해서 dependency에 복붙

3. RedisConfiguration

   1. Redis 환경 변수 가져오기

   2. RedisConnectionFactory bean 생성

      * LettucConnectionsFactory로 생성
      * 실행

   3. RedisTemplate bean 생성

      Redis data에 접근하는 코드를 간단화 해주는 helper

      * setConnection()

      * caching data 설정

        static하고, 자주 접근하는 data를 caching -> User 사용

      * setSerializer()
        * key
        * value

4. 환경변수 설정

   1. Heroku CLI 설치

   2. Heroku CLI로 heroku 환경변수 검색

      `heroku config -a 앱이름`

   3. Redis URL 복사
   4. application.yaml에 붙여넣기

5. RedisRespository 생성
   1. RedisTemplate DI
   2. expire time 설정
   3. SET
      * 로그남기기
      * key에 value 넣기
      * expire time 동안 유지
   4. GET
      * 로그남기기
      * key로 value 읽기
6. Service 수정
   1. 유저 인증(loadUserByUserName)
      1. RedisRespository로 cache에서 검색
         1. 있는 경우 반환
         2. 없는 경우 DB에서 검색
            1. 있는 경우 반환
            2. 없는 경우 USER_NOT_FOUND 에러 
   2. login시 cache에 올리기
      1. 유저 인증결과로 SET하기

7. Redis 확인

   heroku CLI

   1. Redis 실행

      `heroku redis:cli - 앱이름`

   2. key 확인

      `keys *`

   3. key로 value 확인

      `get 키이름`

8. Entity

   1. 필요 없는 값 무시 

      JsonIgnore

   2. @NoArgsConstructor 추가

9. JwtTokenFilter 수정
   1. permitAll() 한부분 -> websecurity로 이동해서 인증확인 부여



# SSE

## 알람 개선

1. 프론트엔드 수정
   1. 최신 알람 앞으로
   2. 한번 실행했을 때 suscribe
   3. 알람이 오면 다시 페이지 호출

2. Controller
   1. subscribe 요청
   2. authentication 가져오기
   3. 로그인 확인
      1. 성공하면 user 반환
      2. 실패하면 INTERNAL_SERVER_ERROR
   4. service 실행
   5. Response 규격화
3. Service
   1. AlaramService
      1. emitterRepository save()
      2. 타임아웃 설정
         1. 완료된후 emitterRepository delete()
         2. 지나면 emitterRepository  delete()
      3. 브라우저에게 연결여부 보내기
         1. 성공시 "connect completetd"
         2. 실패시 ALARM_CONNECT_ERROR
      4. send
         1. 새로운 알람 왔으니 event 보내라고 서버에 요청하기
            1. 보낼게 있는 경우 요청
            2. 에러시 ALARM_CONNECT_ERROR + delete
            3. 없으면 log 출력
   2. PostService 수정
      1. 댓글이나 작성시 
         1. 알람 저장
         2. 서버에게 send() 요청
      2. 좋아요 작성시 send() 함수 실행 추가
         1. 알람 저장
         2. 서버에게 send() 요청

4. EmitterRepository

   local - cache 사용 -> 서버 여러개 사용하면 문제 생김

   1. save 
   2. get
   3. delete
   4. getKey 

5. JwtTokenFilter
   1. subscribe도 Token을 확인해야 하므로 설정
      1. alarm subscribe URL일 시
         1.  query param check
      2. 아닐시 
         1. header check





# Kafka

## 강한 결합성 개선(댓글,좋아요 - 알람)

1. Heroku CloudKarafka 

   1. Heroku adds-on에서 설치

   2.  앱 선택
   3. TOPICS에서 topic 생성
   4. BROWSER
      1. Consumer에서 message보내기
      2. Producer에서 받아오기

2. dependency 추가

   build.gradle

   1. kafaka spring maven 구글링해서 복붙

3. 환경변수 설정

   application.yaml

   1. properties
   2. consumer
   3. listener
   4. producer
   5. topic

4. Producer

   1. 환경변수로 topic 받아오기
   2. kafka template DI
   3. send() 함수
      1. 보내기
         1. topic
         2. 받는사람 id
         3. event
      2. log 남기기

5. Event dto

   1. 받는사람 id
   2. 알람 type
   3. args

6. Consumer

   1. 알람 service DI
   2. KafakaListener - topic 설정
   3. consumeAlarm() 함수
      1. 로그남기기
      2. 알람 service로 알람 보내기
      3. ACK 보내기

7. Service 수정

   1. PostService
      1. Producer DI
      2. 댓글, 좋아요 save() 뒤에 producer에게 보내기
         1. 받는 사람 id
         2. 알람 type
         3. 알람 args
            1. 쓴사람 id
            2. 포스트 id

   2. AlarmService
      1. send 수정
         1. user entity id로 검색
         2. alarm entity id로 검색

   

   



