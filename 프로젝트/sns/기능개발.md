# TDD

실패 테스트 작성 -> 테스트가 성공하도록 수정 -> 리팩토링



## 시퀀스 다이어그램

1. 회원가입

   ![image-20230214172346377](md-images/image-20230214172346377.png)

2. 로그인

![image-20230214172357598](md-images/image-20230214172357598.png)

3. 포스트 작성

   ![image-20230214172427853](md-images/image-20230214172427853.png)

## 회원가입

1. controller test 작성

   1. 컨트롤러

      1. 성공시
         1. isOk()

      2. 실패시
         1. isConflict()

   2. service
      1. 성공
      
      2. 실패
      
         

2. 테스트가 성공하도록 수정

   Controller

   1. postmapping
   2. Userdto 반환

   model

   1. User
      1. id
      2. pwd

   Service

   1. join
      1. User dto 반환

   exception 

   1. RuntimeException 상속

   request dto

   1. UserJoinRequest
      1. id
      2. pwd

---

1. Service test
   1. 정상 회원가입
      1. exception 없음
   2. 아이디 중복 회원가입실패
      1. exception 반환



2. 테스트가 성공하도록 수정

   service

   1. join
      1. findByUserName()
      2. save()

   repository

   1. findByUserName()

## 로그인

Controller



test

1. 성공시
   1. JWT 반환

2. 실패시
   1. 아이디 없음
      1. isNotFoud()
   2. 비밀번호 틀림
      1. isUnauthorized()



request dto

1. UserLoginRequest
   1. id
   2. pwd

Controller

1. JWT 반환

Service

1. 아이디 있는지 확인
2. pwd 맞는 지 확인
3. JWT 반환



Service

test

1. 정상 로그인
   1. exeption 없음
2. 아이디 없음 실패
3. 비밀번호 틀림 실패



service

1. login
   1. 회원가입 여부 (findByUserName())
      1. 성공시 entity 가져오기
      2. 실패시 exception 반환
   2. 비밀번호 체크
      1. 실패시 exception 반환
   3. 토큰 생성



fixture

1. entity 생성
2. id 1
3. username 설정
4. password 설정



## 포스트 작성

1. Controller test

   1. lombok

      1. @SpringBootTest
      2. @AutoConfigureMockMvc

   2. DI

      1. mockMvc,
      2. OpjectMapper
      3. PostService

   3. 테스트코드

      1. 로그인 하고 포스트 작성한 경우 : status.isOk()
      2. 로그인 안하고 포스트 작성한 경우 : status.isConFLICT()

      

2. 테스트가 성공하도록 수정

   1. request dto

      1. title,body

      

---

1. service test

   1. lombok
      1. @SpringBootTest

   2. DI
      1. respository
   3. 테스트 코드 
      1. 로그인 하고 포스트 작성한 경우 
         1. given
            1. title,body,userName
         2. when(mocking)
            1. repository.findByUserName() -> UserEntity
            2. repository.save() -> PostEntity
         3. then
            1. 실행 결과 에러안뜸 확인
      2. 로그인 안하고 포스트 작성한 경우 : 에러뜸
         1. given
            1. title,body,userName
         2. when(mocking)
            1. repository.findByUserName() -> empty
            2. repository.save() -> PostEntity
         3. then
            1. 실행결과 에러코드 확인



2. 테스트가 성공하도록 수정

   1. service
      1. respository DI
      2. create()
         1. @Transactional
         2. repository.findByUserName()
         3. repository.save()
         4. return void
   2. reposiory

   3. Entity

      1. title,body(text)
      2. userEntity(Many to one join)
      3. metat data

      

      

# 개발

## 회원가입

1. 회원가입

   1. Controller

      1. postMapping
      2. request Service에 전달
      3. Service 결과 반환

   2. Service

      1. repository.findByUserName()
         1. 있으면 exception 반환
         2. 없으면 save()

   3. Entity

      DB 저장 용도 -> JPA때문에 분리해야 됨

      1. UserEntity

         1. id,pwd
         2. register_at,updated_at,deleted_at  - 유지보수
         3. 자동시간 입력
            1. 등록시간 by @PrePersist 함수
            2. 수정시간 by @PreUpdate 함수
            3. 삭제시간 by @SQLDelete + @Where

         4. UserRole(권한)

         5. Dto 변환 함수

   4. Dto

      DB외 사용

      1. UserDto
      2. UserJoinResponse
         1. id,userName,role
         2. User dto -> UserJoinResponse

   5. Responsse 규격화

      1. error인경우 : (error code,null) 반환
      2. success인 경우 : ("SUCCESS",result) 반환

   6. Error 처리
      1. enum ErrorCode
         1. 아이디 중복
      2. SimpleException
         1. 메시지가 null 인경우 ; message만 반환
         2. 메시지 있는 경우 : erroCode + message 반환
      3. GlobalControllerAdvice
         1. @RestControllerAdvice
            1. 응답
               1. error status
               2. error code 이름
            2. 에러처리
               1. 로그로 에러코드 출력

   7. DB 설정

      1. application에서 exclude 설정 지우기

      2. application.yaml 에서 설정  **

         1. JPA

            1. db : postgresql
            2. dialet : org.hibernate.dialect.ZPostgreSQLDialect
            3. ddl-auto : update(배포시 validate로 변경)
            4. form_sql : true
            5. show-sql : true

         2. DB

            Heroku에서 확인

            * adds-ons -> find more adds on -> Postgres 선택 -> Install -> free, app 선택 -> submit -> Postgre 클릭 -> Settings -> Database Credentials에 있음

            1. url : jdbc:postgresql:// + Host + / + Database
            2. username : User
            3. password : Password
            4. platform : postgress
            5. driver : org.postgresql.Driver

   8. Post man으로 확인
      1. erro 떳는데 저장됨
      2. 비밀번호가 노출되므로 암호화 필요
   9. test
      1. 에러코드 확인 코드 추가



---

## 로그인

1. 암호화

   1. SecurityConfig

      1. BCriptPasswordEncoder bean 생성

   2. 비밀번호 암호화

      UserService의

      1. BCriptPasswordEncoder DI
      2. join 메소드 return entity의 password encode

   3. AuthenticationConfig

      1. WebSecurityConfigurerAdapter 상속
      2. spring security
         1. 허용 - 회원가입, 로그인
         2. 인증요청 - 그외
         3. 세션 관리 안함



2. 회원가입 에러 발생시 DB 저장 안되게 하기

   1. @Transactional 추가

      UserService의 join 메소드



3. RuntimeException 추가
   1. enum ErrorCode에 에러코드이름(HttpStatus, message) 추가 
   2. GlobalControllerAdvice에 추가 



4. test

   1. join service

      회원가입에 encode 추가



5. 로그인

   1. Controller
      1. PostMapping
   2. enum ErrorCode 추가
      1. 아이디 없음
      2. 비밀번호 틀림
   3. Service 
      1. userName 존재 확인
         1. 있으면 UserEntity 반환
         2. 없으면 (아이디 없음 erroCode) 반환
      2. 비밀번호 틀림
         1. 비밀번호 encode 반영하여 확인
         2. 틀리면 (비밀번호 틀림 erroCode) 반환
   4. JWT 토큰 
      1. build.gradle 추가
         * JJWT :: Impl
         * JJWT :: API
      2. 토큰생성
         1. claim 생성
         2. claim에 userName 담기
         3. JWT build
            1. claim
            2. 발행일
            3. 만기일
            4. key, 알고리즘
            5. 암호화 실행
         4. key 메소드

   5. Service
      1. JWT token
         1. 외부에서 설정한 key, 만기일 사용 설정 : @Value("${이름}")
         2. JWT 토큰 생성 후 반환
   6. application.yaml
      1. key 입력
      2. 만기일 입력
   7. postman으로 확인 
      1. 로그인 맞으면 : resultCode "SUCCESS" + result(암호화된 pwd)
      2. 로그인 틀리면 : resultCode "에러코드 이름" + result(null)
   8. test 수정
      1. 에러 코드 이름 반영
      2. encode한 비밀번호 확인 결과물 DI
      3. 에러코드 이름 확인 코드 추가

   

## 포스트 작성

1. Controller
   1. lombok
      1. @RestController
      2. @RequestMapping()
      3. @RequiredArgsConstructor
   2. Postmapping
   3. spring security로 userName 가져오기
   4. create service 사용
   5. 반환 타입은 Response
2. Entity
   1. Entity of() 생성자 
3. service
   1. repository.finByUserName()
      1. 있으면 entity
      2. 없으면 error(errorcode,message)
   2. repository.save()

4. userName 가져오기 설정
   1. AuthenticationsConfig
      1. filterBefore 추가
         1. UsernamePasswordAuthenticationFilter 전에 JwtTokenFilter 적용
   2. JwtTokenFilter
      1. 정상작동
         1. get header
            1. header 없으면 return filterchain
         2. token 가져오기
         3. token이 유효한지 확인(만기일) by JwtTokenUtils
            1. 비유효하면 로그남기기
            2. filterchane
         4. token으로 userName 가져오기 by JwtTokenUtils
         5. userName 존재 여부 확인
         6. UsernamePasswortAuthenticationToken 생성
            1. user
            2. credentials
            3. authorites
         7. 생성할걸로 인증 생성
      2. 에러시
         1. 로그남기기
         2. return filterchain
      3. filterchain

5. controller
   1. Authentication에서 userName 받아올 수 있음

6. JwtTokenUtils

   1. 만기일 확인
      1. claims 가져오기

   2. userName 가져오기

7. service
   1. userName 존재 여부 확인 함수 추가

8. AuthenticationConfig
   1. userService DI
   2. key 값 가져오기

9. Postman으로 확인

   1. UsernamePasswortAuthenticationToken에서 에러 발생

   2. Token invalid시 처리 안함

      

---

1. UsernamePasswortAuthenticationToken에서 에러 발생
   1. User Entity에서 getName()을 구현
      1. Userdetails implemetns
      2. 함수 구현
         1. getAuthorities()
         2. getUsername()
         3. isAccountNonExpired()
         4. isAccountNolocked()
         5. isCredentialsNonExpired()
   2. JwtTokenFilter UsernamePasswortAuthenticationToken 생성자 수정
      1. authorites -> user.getAuthorities()

2. Token invalid시 처리

   1. AuthenticationConfig
      1. EntryPoint 생성
         1. contentType : json
         2. status 설정 : INVALIE_TOKEN
         3. response에 내용 적기(에러코드, result)

   2. enum ErrorCode
      1. INVALID_TOKEN 에러코드 추가
