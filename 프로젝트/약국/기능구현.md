# Kakao 주소검색 api 구현

1. 주소 검색 API 가이드

   https://developers.kakao.com/docs/latest/ko/local/dev-guide 

   1. Request
   2. Response
   3. Documents(변수 이름)

2. 검증

   1. 호출 제한 확인

      https://developers.kakao.com/terms/latest/ko/site-policies#quota

   2. API 테스트

      1. key 받기

         https://developers.kakao.com/

         1. 로그인
         2. 내 애플리케이션 클릭 -> 추가하기

      2. Postman으로 API 테스트

         1. 입력
            1. URI
            2. key
            3. query
         2. 출력 확인

   





# Spock를 이용한 테스트 코드 작성하기

1. 단일 test

   1. uri builder에서 encoding 되는지 확인

      1. given : address, charset 입력

      2. when : encoding된 uri를 decoding 
         1. 결과값을 def로 정의(값이 동적이므로)

      3. then : 결과값 비교





# Testcontainers를 이용하여 독립 테스트 환경 구축하기

1. 통합 테스트
   1. dependency 추가
      * Spock
   2. applications.yml 작성
      * JDBC
      * JPA
      * REST API KEY
   3. 테스트 코드 작성
      1. Generic container 생성
      2. CRUD 테스트
      3. Edit configure에서 환경 변수 등록



# Spring Data JPA를 이용한 CRUD 메서드 구현하기

1. repository 작성
2. dependency 추가
3. 주의사항
   * 트랜잭션 밖에서 데이터 변경은 반영되지 않는다.
4. 영속성 context 있는 이유
   1. 1차 캐시 
      * 1차 캐시에 이미 있는 값을 조회하는 경우 : DB 조회 안하고 1차 캐시에서 가져옴
      * 1차 캐시에 없는 경우 : DB 조회
   2. 쓰기 지연
      * flush를 해야 DB에 반영됨
   3. 엔티티 수정(Dirty checking)
      1. 한꺼번에 entity 변경사항을 DB에 반영함





# JPA Dirty Checking

1. 과정

   1. 영속성 context에 snapshot 저장
      * entity 상태 변경 검사 용도

   2. 변화가 있는 entity는 쓰기 지연 SQL 저장소에 UDATE SQL 생성

   3. flush 하면 쓰기 지연 SQL 저장소에 있는 쿼리를 DB에 반영

2. 주의사항

   1. 영속 상태 이어야 됨

      영속 상태가 아니면 변경해도 반영이 안됨

   2. 트랜잭션 있어야 됨

      트랜잭션이 끝나야 flush가 되어 DB에 반영이 된다.



# JPA Auditing으로 생성시간/수정시간 자동화 구현

* 사용 이유

  entity마다 공통적으로 필요한 값 -> 유지보수에 필요 -> 코드 반복 피하기 위해서 사용

* JPA Auditing이란?
  * @MappedSuperclass : 엔티티의 공통 매핑 정보
  * @EntityListeners : 해당 클래스에 auditing 기능을 포함
  * @CreatedDate : Entity가 생성된 시간을 자동 저장
  * @LastModifiedDate : Entity 변경될 때 시간 자동 update



# Spring Transactional 

* 개념

  proxy 객체에게 transaction 관리 권한을 위임함 -> 개발에 집중

* 주의사항

  1. Self Invocation

     내부 메소드로 내부메소드를 호출하면 proxy가 생성이 안됨 -> Transactions 관리가 기능을 못함

  2. @Transactional(readOnly = true) 
     * 트랜잭션을 읽기 전용으로 설정 -> JPA에서 snapshot 비교 안함 -> Dirty Checking 안함 -> 성능 이점
     * 우선순위 : class < method

* 해결법

  1. Self Invocation

     1. 메소드 분리

     2. 외부에서 호출



# 약국 데이터 셋업

1. 직접 sql 생성 하기

   * [공공데이터 포탈](https://www.data.go.kr/data/15065023/fileData.do ) 참고

2. Docker container 생성 시 초기 데이터 만들기

   1. /database/init/에 sql파일 넣기

   2. docker-compose에 추가

      * 위치 매핑

      ```
      volumes:
      	- ./database/init:/docker-entrypoint-initdb.d
      ```

3. Entity와 DB가 일치하는지 확인 설정

   application.yml

   jpa.hibernate.ddl-auto:validate

4. 확인

   1. docker container 확인

      `docker ps`

   2. 환경 접속

      `docker exec -it {CONTAINER ID} bash`

   3. DB 접속

      `mysql -uroot -p`

      비밀번호 입력

   4. DB 확인

      `show daatabases;`

   5. table 확인

      `use {DB이름}`

      `show tables`

   6. 값 확인

      `select * from {table 이름}`

5. service 추가
   1. 사용자가 원하는 정보 List 출력 구현
      1. @Transactional(readOnly = true)
      2. repository.findAll()





# 거리계산 알고리즘 구현

* Haversine formula 알고리즘 사용

  지구가 완벽한 구가 아니라서 0.5% 정도 오차가 발생 가능



* entity와 dto 분리하는 이유

  entity 변경 = DB 변경 -> 유지보수

  한 메소드 안에서 dto 관리

1. DB에서 받은 entity를 dto로 변환
2. 거리계산
3. 가장 가까운 병원 3개 출력



# 거리계산 테스트 케이스 작성

테스트에서 DB를 사용안하고 값을 설정하기 위해서 mock을 사용

DirectionsServiceTest.groovy 참고

1. 거리 정렬 확인
2. 반경 10 km 이내 확인





# Spring retry 구현 및 검증

외부 API를 사용하므로 설정

* 재시도를 몇 번 실행할 것인가? - 최대 2회
* 재시도 하기전 지연시간은 얼마나 줄것인가? - 3초 
* 재시도 모두 실패했을 경우 어떻게 처리할 것인가? - recover 메소드 실행 - log 남기기



Annotation으로 Spring retry 

https://wonyong-jang.github.io/spring/2021/02/18/Spring-Retry.html 참고



1. dependency 추가
   * Spring retry
   * Spring MockWebServer
2. RetryConfig
   * Annotation
     * @EnableRetry
     * @Configuration
3. Service
   1. 카카오 API 사용하는 메소드에 Annotation 추가
      * @Retryable
        * value = {RuntimeException.class} // retry하는 오류 설정
        * maxAttempts = 2 // 최대 2회
        * backoff = @Backoff(delay=2000) // 2초
   2. recover 함수 추가
      1. @Recover
      2. retry 실패시 실행할 함수 작성(return type은 @Retry 한 함수와 일치해야 됨) - log 남김

4. 테스트

   1. 테스트 코드 작성

      1. 통합 테스트 상속

      2. mocking 

         1. URI builder -  @SpringBean

      3. 확인

         1. Exception이 발생했을 때 정상적으로 처리되는지
            1. given 
               1. responseDto에 필요한 값들 입력
               2. uri 를 mockWebServer로 생성
            2. when
               1. response 코드 설정
            3. then
               1. retry 횟수 확인
               2. response 내용 확인

         2. 모두 실패했을 때 reover함수가 호출이 되는지
            1. given 
               1. uri 를 mockWebServer로 생성
            2. when
               1. response 코드 설정
            3. then
               1. recover 함수 호출 확인

   2. 환경변수 입력(API KEY)
   3. 실행



# 추천 결과 저장

1. repository 생성
2. service 
   1. 결과 저장

3. 테스트
   1. where 사용







# 카카오 키워드 장소 검색 api 적용

* KAKAO REST API 공식문서 확인

* Postman으로 kakao REST API 사용해보기
  * params 입력
  * headers에 Authorization 입력



비즈니스 로직 -> REST API로 바꾸기

* Document dto 수정
  * 장소 카테고리
  * 거리
* uriBuilderService 메소드 추가
  * 입력 정보(위도,경도,반경,카테고리)로 uri build 

* SearchService 추가
  * DI
    * uriBuilderService 
    * restTemplate
  * 환경변수로 REST API KEY 받기
  * 메소드 구현
    * uri build
    * header에 key 넣기
    * restTemplate 사용

* DirectionService 메소드 추가
  * 공공데이터 API가 아닌 KAKAO API에서 받아오기
  * dto로 변환 + limit 3개









- 카카오 주소검색 API 연동하여 주소를 위도, 경도로 변환하기
- 추천 결과를 카카오 지도 URL로 연동하여 제공하기
- 공공 데이터를 활용하여 개발하기 (약국 현황 데이터)
- Handlebars를 이용한 간단한 View 만들기
- 도커를 사용하여 다중 컨테이너 애플리케이션 만들기
- 애플리케이션을 클라우드 서비스에 배포하기
- Spring retry를 이용한 재처리 구현하기 (카카오 API의 네트워크 오류 등에 대한 재처리)
- base62를 이용한 shorten url 개발하기 (길안내 URL)
- redis를 이용하여 성능 최적화하기