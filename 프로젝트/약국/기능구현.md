# Kakao 주소검색 api 구현

1. 주소 검색 API 가이드

   https://developers.kakao.com/docs/latest/ko/local/dev-guide 

   1. Request
   2. Response
   3. Documents(변수 이름)

2. 검증

   1. 호출 제한 확인

      https://developers.kakao.com/terms/latest/ko/site-policies#quota

   2. API 테스트

      1. key 받기

         https://developers.kakao.com/

         1. 로그인
         2. 내 애플리케이션 클릭 -> 추가하기

      2. Postman으로 API 테스트

         1. 입력
            1. URI
            2. key
            3. query
         2. 출력 확인

   





# Spock를 이용한 테스트 코드 작성하기

1. 단일 test

   1. uri builder에서 encoding 되는지 확인

      1. given : address, charset 입력

      2. when : encoding된 uri를 decoding 
         1. 결과값을 def로 정의(값이 동적이므로)

      3. then : 결과값 비교





# Testcontainers를 이용하여 독립 테스트 환경 구축하기

1. 통합 테스트
   1. dependency 추가
      * Spock
   2. applications.yml 작성
      * JDBC
      * JPA
      * REST API KEY
   3. 테스트 코드 작성
      1. Generic container 생성
      2. CRUD 테스트
      3. Edit configure에서 환경 변수 등록



# Spring Data JPA를 이용한 CRUD 메서드 구현하기

1. repository 작성
2. dependency 추가
3. 주의사항
   * 트랜잭션 밖에서 데이터 변경은 반영되지 않는다.
4. 영속성 context 있는 이유
   1. 1차 캐시 
      * 1차 캐시에 이미 있는 값을 조회하는 경우 : DB 조회 안하고 1차 캐시에서 가져옴
      * 1차 캐시에 없는 경우 : DB 조회
   2. 쓰기 지연
      * flush를 해야 DB에 반영됨
   3. 엔티티 수정(Dirty checking)
      1. 한꺼번에 entity 변경사항을 DB에 반영함





# JPA Dirty Checking

1. 과정

   1. 영속성 context에 snapshot 저장
      * entity 상태 변경 검사 용도

   2. 변화가 있는 entity는 쓰기 지연 SQL 저장소에 UDATE SQL 생성

   3. flush 하면 쓰기 지연 SQL 저장소에 있는 쿼리를 DB에 반영

2. 주의사항

   1. 영속 상태 이어야 됨

      영속 상태가 아니면 변경해도 반영이 안됨

   2. 트랜잭션 있어야 됨

      트랜잭션이 끝나야 flush가 되어 DB에 반영이 된다.



# JPA Auditing으로 생성시간/수정시간 자동화 구현

* 사용 이유

  entity마다 공통적으로 필요한 값 -> 유지보수에 필요 -> 코드 반복 피하기 위해서 사용

* JPA Auditing이란?
  * @MappedSuperclass : 엔티티의 공통 매핑 정보
  * @EntityListeners : 해당 클래스에 auditing 기능을 포함
  * @CreatedDate : Entity가 생성된 시간을 자동 저장
  * @LastModifiedDate : Entity 변경될 때 시간 자동 update



# Spring Transactional 

* 개념

  proxy 객체에게 transaction 관리 권한을 위임함 -> 개발에 집중

* 주의사항

  1. Self Invocation

     내부 메소드로 내부메소드를 호출하면 proxy가 생성이 안됨 -> Transactions 관리가 기능을 못함

  2. @Transactional(readOnly = true) 
     * 트랜잭션을 읽기 전용으로 설정 -> JPA에서 snapshot 비교 안함 -> Dirty Checking 안함 -> 성능 이점
     * 우선순위 : class < method

* 해결법

  1. Self Invocation

     1. 메소드 분리

     2. 외부에서 호출



# 약국 데이터 셋업

1. 직접 sql 생성 하기

   * [공공데이터 포탈](https://www.data.go.kr/data/15065023/fileData.do ) 참고

2. Docker container 생성 시 초기 데이터 만들기

   1. /database/init/에 sql파일 넣기

   2. docker-compose에 추가

      * 위치 매핑

      ```
      volumes:
      	- ./database/init:/docker-entrypoint-initdb.d
      ```

3. Entity와 DB가 일치하는지 확인 설정

   application.yml

   jpa.hibernate.ddl-auto:validate

4. 확인

   1. docker container 확인

      `docker ps`

   2. 환경 접속

      `docker exec -it {CONTAINER ID} bash`

   3. DB 접속

      `mysql -uroot -p`

      비밀번호 입력

   4. DB 확인

      `show daatabases;`

   5. table 확인

      `use {DB이름}`

      `show tables`

   6. 값 확인

      `select * from {table 이름}`

5. service 추가
   1. 사용자가 원하는 정보 List 출력 구현
      1. @Transactional(readOnly = true)
      2. repository.findAll()





# 거리계산 알고리즘 구현



# 거리계산 테스트 케이스 작성



# Spring retry 구현 및 검증



# 추천 결과 저장



# 카카오 키워드 장소 검색 api 적용







- 카카오 주소검색 API 연동하여 주소를 위도, 경도로 변환하기
- 추천 결과를 카카오 지도 URL로 연동하여 제공하기
- 공공 데이터를 활용하여 개발하기 (약국 현황 데이터)
- Handlebars를 이용한 간단한 View 만들기
- 도커를 사용하여 다중 컨테이너 애플리케이션 만들기
- 애플리케이션을 클라우드 서비스에 배포하기
- Spring retry를 이용한 재처리 구현하기 (카카오 API의 네트워크 오류 등에 대한 재처리)
- base62를 이용한 shorten url 개발하기 (길안내 URL)
- redis를 이용하여 성능 최적화하기