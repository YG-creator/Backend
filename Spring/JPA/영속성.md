# 영속성이란?

파일이나 DB에 저장해서 데이터가 영구적으로 존재할 수 있도록 하는 것



# 설정

1. DB 동작시키기

   Terminal -> mysqld 입력

2. application.yml 설정

   main -> resources -> application.yml 설정

   ```yml
   spring:
     h2:
       console:
         enabled: true
     jpa:
       show-sql: true
       properties:
         hibernate:
           format_sql: true
       generate-ddl: true			# 추가 -> 자동으로 Entity에서 활용하고 있는 table을 생성해줌  								   # h2에서는 true가 default, 실제는 자동화된 ddl은 리스크가 있어서 안함
       hibernate:
         ddl-auto: create-drop		# 추가 -> persistence context를 띄울 때 create 종료할 때 drop							   # 실제는 자동화된 ddl은 리스크가 있어서 안함
         
     datasource:					# 추가 -> h2 dialect를 MySQL dialect로 변경
       url: jdbc:mysql://localhost:DB포트번호/DB이름
       username: root
       password:
       initialization-mode: always # -> 항상 data.sql 로딩해서 초기화 -> 실제로는 none으로 함 
   server:
     port: 8070
   ```

3. dependencies 설정

   build.gradle -> dependencies 설정 추가

   ```java
   dependencies {
       implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
       implementation 'org.springframework.boot:spring-boot-starter-web'
       compileOnly 'org.projectlombok:lombok'
       runtimeOnly 'com.h2database:h2'
       runtimeOnly 'mysql:mysql-connector-java'	// 추가
       annotationProcessor 'org.projectlombok:lombok'
       testImplementation 'org.springframework.boot:spring-boot-starter-test'
   }
   ```

4. DB 생성

   오른쪽 database ->  + -> data source -> MySQL -> user : root -> advanced -> serverTimeZone : Asia/Seoul 입력

5. 오류해결

   1. JpaConfiguration class 생성

      ```java
      // JPA metmodel mut not be empty 오류 처리
      @Configuration
      @EnableJpaAuditing
      public class JpaConfiguration {
      }
      ```

   2. @Transcactional

      실패하면 roleback 성공하면 commit     



# 캐시

1. 알아야 하는 이유

   영속성 context와 실제 DB data간 차이 발생

2. 영속성 캐시 사용사례(findById)

   Entity 캐시에서 해당 Id가 없으면 DB에서 가져오고  /  있으면 영속성 context에서 가져옴

3. 영속성 부여 시점 

   1. flush()

   2. Transaction 끝나서 commit 되는 시점

   3. 복잡한 조회조건에 jpql이 시행되는 시점



# 생명주기

1. 생명주기

   영속성 context -> commit해서 DB에 저장하기 -> DB에서 가져오기 -> 영속성 context 

2. EntityManger 

   자동적으로 영속성 관리해줌(commit 관리)

3. EntityManger 영속성 관리 함수
   * entitymanger.persist() : 영속화
   * detach() : 준영속화(flush해줘야 영속화됨)
   * merge() : 영속성 context에 변경사항 합치기 
   * clear() : 비영속화(변경된 data drop)
   * remove(Entity) : 삭제

4. 그 외 영속화 방법

   repository.save() : 영속화



# 트랜잭션

1. 개념

   DB 명령어들의 논리적인 묶음

2. 특징(ACID)

   Atomicity(원자성) : yes or no

   Consistench(일관성) : 데이터간의 정합성 

   Isolation(독립성) : 다른 트랜잭션 영향 ㄴ 

   Durability(영속성) : 데이터는 영구적으로 보관됨

3. 설정

   @Transactional : 성공하면 영속성 부여, 실패하면 rollback

